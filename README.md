در ابتدا پروژه را از گیت‌هاب درس برداشته و طبق گفته‌ی صورت آزمایش، تنها MiniJava را نگه‌میداریم و Graph را از پروژه حذف می‌کنیم.
در ادامه الگوهای طراحی ذکر شده در صورت سوال را اعمال می‌کنیم:

 **اعمال الگوی Facade:**

۱- یک مشکل اساسی که وجود داشت این بود که کلاس LexicalAnalyzer مستقیما در Parser استفاده می‌شد و این باعث می‌شد وابستگی خیلی زیاد شود، خوانایی کم شود و کد خیلی پیچیده به نظر بیاید. برای حل این مشکل از الگوی طراحی Facade استفاده کردیم و یک کلاس جدید به اسم ScannerFacade ساختیم. این کلاس نقش یه واسط ساده را داشت که پیچیدگی‌های LexicalAnalyzer را از Parser پنهان کرد و کار را خیلی راحت‌تر کرد. برای اعمال این الگو در ابتدا ScannerFacade را ساختیم تا مدیریت ارتباط با LexicalAnalyzer را انجام دهد، سپس Parser را اصلاح کردیم که دیگر مستقیم با LexicalAnalyzer کار نکند و از ScannerFacade استفاده کند. در نهایت بعد از تغییرات خروجی‌مان را با خروجی کد اصلی تست کردیم تا مطمئن شویم همه چیز درست کار می‌کند. با این کار، پیچیدگی تحلیل واژگانی پنهان شد، وابستگی بین Parser و LexicalAnalyzer کمتر شد، کد خواناتر و راحت‌تر برای نگهداری شد و تست و توسعه پروژه هم ساده‌تر شد همچنین انعطاف‌پذیرتر شد.

۲- در این قسمت، قبلا در کلاس Main همه جزئیات مربوط به پارسینگ مستقیم نوشته می‌شد. یعنی Main هم باید شی Parser را می‌ساخت و هم خودش عملیات شروع پارسینگ را انجام می‌داد. این کار باعث می‌شد کد هم شلوغ بشه و هم خیلی وابسته به جزئیات پیاده‌سازی کلاس Parser باشد. حال در این تغییر آمدیم یه کلاس جدید به اسم ParserFacade ساختیم. این کلاس عملا یه واسط یا همان Facade شده بین کلاس Main و کلاس Parser. یعنی Main دیگر لازم نیست درگیر جزئیات کار Parser شود و فقط کافی است یه شی از ParserFacade بسازد و متد parseInput را کال کند. در واقع ParserFacade خودش داخلش کارهای مربوط به Parser را انجام می‌دهد و اگه خطایی هم پیش بیاید، همان‌جا هندل می‌کند. در این صورت همه مسئولیت‌های پارسینگ و مدیریت خطاها از Main جدا شده و به یک کلاس مستقل منتقل شده. 

همچنین برای خطاها هم یک تغییر کوچیکی در کلاس Main دادیم که اگر فایل پیدا نشد، پیام واضح‌تری چاپ می‌شود: "file not found". اما اگر خطای دیگه‌ای داخل پارسینگ رخ بدهد، این خطا در ParserFacade مدیریت می‌شود و پیام مناسب "An error occurred during parsing" چاپ می‌شود.

نقش Facade Pattern دقیقا همین است که در کدهای پیچیده یک رابط ساده و قابل استفاده به بیرون ارائه دهد. یعنی ما یک کلاس می‌سازیم (مثل ParserFacade) که مسئول هماهنگ کردن و مدیریت کردن کارهای مربوط به سیستم‌های داخلی (مثل Parser) هست. در این صورت بقیه کدها، مثل Main، دیگر لازم نیست درگیر جزئیات پیچیده بشوند و فقط از این رابط ساده استفاده می‌کنند. این کار هم کد را خواناتر می‌کند و هم وابستگی بین بخش‌های مختلف کد را کم می‌کند.

 **اعمال الگوی استفاده از Polymorphism به جای شرط:**

این الگوی بازآرایی در کدهایی مناسب است که ما یک شرطی داریم که بسته به خصوصیات مختلف اعمال مختلفی را انجام می دهد، برای مثال switch case ها. برای بازآرایی این نوع کد ها با کمک polymorphism می‌بایست کلاس های فرعی مطابق با شاخه های شرطی ایجاد کنیم، سپس در آنها یک متد اشتراکی ایجاد می‌کنیم و کد را از شاخه مربوط به شرطی به آن منتقل می‌کنیم. سپس شرط را با فراخوانی متد مربوطه جایگزین کرده و  نتیجه این است که پیاده سازی مناسب از طریق پلی مورفیسم بسته به کلاس شی حاصل می شود. 

در این پروژه ما این بازآرایی رو کلاس address و به ویژه تابع to string انجام می‌دهیم که از شرط به صورت switch case استفاده کرده است. برای اینکار باید TypeAddress enum را با polymorphism جایگذاری کنیم. در ابتدا یک اینترفیس AddressType می‌سازیم و در آن تابع format را تعریف می‌کنیم برای هر کدام از تایپ‌‌های آدرس که در switch case ها داشتیم. به این ترتیب، با فراخوانی این تابع، به‌طور خودکار عملکرد switch-case حذف شده انجام می‌شود. سپس برای هر کدام از آدرس تایپ‌ها یک کلاس جداگانه تعریف می‌کنیم.اگر شیئی که تابع بر روی آن فراخوانی می‌شود از هر یک از انواع این کلاس‌ها باشد، تابع مربوط به آن کلاس به‌طور صحیح اجرا خواهد شد. 


 **اعمال الگوی Separate Query From Modifier:**

در این قسمت Separate Query from Modifier را پیاده سازی کردیم. این الگوی طراحی می‌گوید که بهتر است متدها یا فقط اطلاعات را برگردانند (Query) یا وضعیت برنامه را تغییر بدهند (Modifier)، نه اینکه هر دو کار را با هم انجام بدهند. این کار باعث می‌شود کد خیلی تمیزتر، واضح‌تر و قابل پیش‌بینی‌تر شود.  حال در این کدی که تغییر دادیم، یک‌سری متد مثل getTemp() و getDateAddress() هم مقدار را برمی‌گردانند و هم وضعیت برنامه را تغییر می‌دادند (مثلا مقدار یک متغیر را زیاد می‌کردند). این کار باعث می‌شد هر بار که این متدها کال می‌شدند، وضعیت برنامه یک جورایی مخفیانه تغییر می‌کرد و ممکن بود باگ‌ها و مشکلات عجیبی پیش بیاد.  برای حل این مشکل، متدهایی مثل increaseTemp() و increaseDateAddress() را جدا کردیم که فقط وظیفه تغییر وضعیت را دارند. در عوض getTemp() و getDateAddress() فقط مقدار را برمی‌گردانند بدون اینکه تغییری ایجاد کنند. 

در این صورت خیلی راحت می‌شود فهمید که هر متد دقیقا چه کاری انجام می‌دهد و رفتار برنامه هم قابل پیش‌بینی‌تر می‌شود. همچنین تست کردن کد خیلی آسان‌تر می‌شود، چون می‌توان متدهای تغییر وضعیت و متدهای برگرداندن اطلاعات را جداگانه تست کرد؛ یا خطاهای عجیبی که به خاطر تغییرات غیرمنتظره پیش می‌آید خیلی کمتر شود و برنامه پایدارتر شود.  مثلا در کلاس CodeGenerator اول increaseTemp() را کال می‌کنیم تا وضعیت آپدیت شود و بعدش getTemp() مقدار نهایی را برمی‌گرداند. یا در SymbolTable هم همین کار را کردیم و قبل از استفاده از مقدار جدید، متد increaseDateAddress() وضعیت را آپدیت می‌کند.


**سوالات:**


**سوال ۱:**


کد تمیز (Clean Code):
کدی که ساده، قابل خواندن، قابل درک برای دیگر توسعه‌دهندگان و به راحتی قابل نگهداری و توسعه باشد و کمترین پیچیدگی و ابهام را داشته باشد. به عبارتی کد تمیز کدی است که بعد از دو هفته آن کدی که خودمان نوشتیم را ببینیم (یا دگیران ببینند) بتوانیم ازش سر دربیاوریم و بدون مشکل آن را تغییر دهیم (در صورت لزوم).

بدهی فنی (Technical Debt):
هزینه‌ی اضافی و کارهای عقب‌افتاده‌ای است که به‌دلیل راه‌حل‌های میان‌بر و غیر اصولی در کد، در آینده برای نگهداری و توسعه گریبان‌گیر ما می‌شود. (در ابتدا قصد دارند کیفیت را فدای سرعت و راه حل‌های موقت کنند و ولی در انتها ضرر می‌کنند و احتمالا باید زمان بیشتری بگذارند تا اصلاحش کنند.).

بوی بد کد (Bad Smell):
نشانه‌ای در کد که نشان‌دهنده وجود اشکال در طراحی، ساختار یا پیاده‌سازی است و می‌تواند در آینده مشکلات نگهداری و توسعه ایجاد کند. مثلا کدی که فعلا کار می‌کند ولی حس می کنیم که یک چیزی این قسمت اشتباه است

**سوال ۲:**

**۱- بادکنکی‌ها یا Bloaters**

بخش‌هایی از کد، کلاس‌ها یا متدهایی که بیش از حد بزرگ یا پیچیده شده‌اند و فهمیدن آن برایمان یا مدیریت و کار با آن‌ها برایمان دشوار شده است.
این مشکلات معمولا به مرور زمان به‌خصوص وقتی که کسی تلاشی برای بهبود آنها نکند، ایجاد می‌شوند.

برای مثال:

متد طولانی (long method): متدی که وظایف زیادی انجام می‌دهد و بیش از حد طولانی شده است.

کلاس بزرگ (large class): کلاسی که مسئولیت‌های زیادی دارد و باید به چند کلاس کوچک‌‌تر تقسیم شود.

شیفتگی به انواع اولیه (primitive obsession): استفاده بیش از حد و متعصبانه از primitive‌ها به جای کلاس‌های پیچیده‌تر.

لیست پارامتر طولانی (long parameter list): متدی که تعداد زیادی پارامتر می‌گیرد و باعث پیچیدگی می‌شود.
      
توده داده‌ها (data clumps): دسته‌ای از داده‌ها که همیشه با هم ظاهر می‌شوند و باید به یک کلاس مستقل تبدیل شوند.


**۲- سوءاستفاده‌کنندگان شی‌گرایی (Object-Orientation Abusers**)

این دسته شامل مواردی است که اصول برنامه‌نویسی شی‌گرا به درستی یا کامل اجرا نشده‌اند  مثلا استفاده نابه‌جا از switch یا درست رعایت نکردن وراثت که به طور جزئی‌تر مثال‌هایی در ادامه زدیم.

مثال:

کلاس‌های جایگزین با رابط‌های متفاوت (Alternative Classes with Different Interfaces): کلاس‌هایی که مسئولیت‌های مشابهی دارند اما به شکل متفاوتی پیاده‌سازی شده‌اند.

ارث‌بری رد شده (Refused Bequest): زمانی که یک کلاس فرزند از قابلیت‌های کلاس والد استفاده نمی‌کند.

دستورهای switch (Switch Statements): استفاده از دستورهای شرطی زیاد به جای استفاده از پلی‌مورفیسم.

فیلد موقت (Temporary Field): فیلدی که فقط در شرایط خاصی مقداردهی می‌شود و استفاده مداومی ندارد.


**۳- تغییرناپذیرها یا موانع تغییر (Change Preventers)**

کدهایی که با تغییر در یک بخش، نیاز به تغییرات زنجیره‌ای و گسترده در بخش‌های دیگر ایجاد می‌کند و توسعه‌ی کد را هزینه‌بر و سخت می‌کند.

برای مثال:

تغییر واگرا (Divergent Change): یک کلاس که نیازمند تغییرات متفاوت برای نیازهای مختلف است.

سلسله‌مراتب‌های ارث‌بری موازی (Parallel Inheritance Hierarchies): زمانی که برای اضافه کردن یک قابلیت، باید در چندین کلاس مرتبط تغییرات اعمال شود.

جراحی پراکنده (Shotgun Surgery): تغییر در یک بخش نیازمند تغییرات پراکنده در بخش‌های دیگر است.


**۴- غیرضروری‌ها یا زائد‌ها (Dispensables)**
   
مواردی هستند که بودنشان هیچ ارزشی به کد اضافه نمی‌کند (غیر ضروری و یا بلااستفاد) و حتی باعث پیچیدگی بیشتر می‌شود. حذف این بخش‌ها کد را تمیزتر، ساده‌تر بهینه‌تر و قابل فهم‌تر می‌کند.

  برای مثال:

کامنت‌های اضافی: توضیحاتی که به جای روشن کردن کد، پیچیدگی یا ابهام ایجاد می‌کنند.
        
کد تکراری (duplicate): کدهایی که در بخش‌های مختلف کپی شده‌اند به جای اینکه در یک مکان مشترک استفاده شوند.

کد مرده (dead code): بخش‌هایی از کد که دیگر استفاده نمی‌شوند.
        
کلاس تنبل (lazy class): کلاسی که کار خاصی انجام نمی‌دهد و می‌تواند حذف یا با کلاس دیگری ترکیب شود.

**۵- اتصال‌دهنده‌ها (Couplers)**

این بوها نشان‌دهنده وابستگی بیش از حد بین کلاس‌ها یا استفاده افراطی از واگذاری مسئولیت هستند که باعث پیچیدگی و سختی مدیریت می‌شود.

برای مثال:

حسادت به ویژگی‌ها (Feature Envy): زمانی که یک کلاس بیش از حد به داده‌های کلاس دیگر وابسته است و از عناصر آن استفاده می‌کند.

صمیمیت نامناسب (Inappropriate Intimacy): دو کلاس که بیش از حد به جزئیات داخلی یکدیگر وابسته هستند.
        
کلاس کتابخانه ناقص (Incomplete Library Class): کلاسی که باید قابلیت‌های بیشتری ارائه دهد اما ناقص است.
        
زنجیره پیام‌ها (Message Chains): زمانی که یک آبجکت به طور مکرر از چند شی دیگر درخواست می‌کند.
        
واسطه‌گری غیرضروری (Middle Man): کلاسی که فقط درخواست‌ها را به کلاس دیگر منتقل می‌کند و خودش کار خاصی انجام نمی‌دهد.
