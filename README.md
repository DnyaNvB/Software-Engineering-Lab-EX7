در ابتدا پروژه را از گیت‌هاب درس برداشته و طبق گفته‌ی صورت آزمایش، تنها MiniJava را نگه‌میداریم و Graph را از پروژه حذف می‌کنیم.
در ادامه الگوهای طراحی ذکر شده در صورت سوال را اعمال می‌کنیم:

 **اعمال الگوی Facade:**

۱- یک مشکل اساسی که وجود داشت این بود که کلاس LexicalAnalyzer مستقیما در Parser استفاده می‌شد و این باعث می‌شد وابستگی خیلی زیاد شود، خوانایی کم شود و کد خیلی پیچیده به نظر بیاید. برای حل این مشکل از الگوی طراحی Facade استفاده کردیم و یک کلاس جدید به اسم ScannerFacade ساختیم. این کلاس نقش یه واسط ساده را داشت که پیچیدگی‌های LexicalAnalyzer را از Parser پنهان کرد و کار را خیلی راحت‌تر کرد. برای اعمال این الگو در ابتدا ScannerFacade را ساختیم تا مدیریت ارتباط با LexicalAnalyzer را انجام دهد، سپس Parser را اصلاح کردیم که دیگر مستقیم با LexicalAnalyzer کار نکند و از ScannerFacade استفاده کند. در نهایت بعد از تغییرات خروجی‌مان را با خروجی کد اصلی تست کردیم تا مطمئن شویم همه چیز درست کار می‌کند. با این کار، پیچیدگی تحلیل واژگانی پنهان شد، وابستگی بین Parser و LexicalAnalyzer کمتر شد، کد خواناتر و راحت‌تر برای نگهداری شد و تست و توسعه پروژه هم ساده‌تر شد همچنین انعطاف‌پذیرتر شد.

۲- در این قسمت، قبلا در کلاس Main همه جزئیات مربوط به پارسینگ مستقیم نوشته می‌شد. یعنی Main هم باید شی Parser را می‌ساخت و هم خودش عملیات شروع پارسینگ را انجام می‌داد. این کار باعث می‌شد کد هم شلوغ بشه و هم خیلی وابسته به جزئیات پیاده‌سازی کلاس Parser باشد. حال در این تغییر آمدیم یه کلاس جدید به اسم ParserFacade ساختیم. این کلاس عملا یه واسط یا همان Facade شده بین کلاس Main و کلاس Parser. یعنی Main دیگر لازم نیست درگیر جزئیات کار Parser شود و فقط کافی است یه شی از ParserFacade بسازد و متد parseInput را کال کند. در واقع ParserFacade خودش داخلش کارهای مربوط به Parser را انجام می‌دهد و اگه خطایی هم پیش بیاید، همان‌جا هندل می‌کند. در این صورت همه مسئولیت‌های پارسینگ و مدیریت خطاها از Main جدا شده و به یک کلاس مستقل منتقل شده. 

همچنین برای خطاها هم یک تغییر کوچیکی در کلاس Main دادیم که اگر فایل پیدا نشد، پیام واضح‌تری چاپ می‌شود: "file not found". اما اگر خطای دیگه‌ای داخل پارسینگ رخ بدهد، این خطا در ParserFacade مدیریت می‌شود و پیام مناسب "An error occurred during parsing" چاپ می‌شود.

نقش Facade Pattern دقیقا همین است که در کدهای پیچیده یک رابط ساده و قابل استفاده به بیرون ارائه دهد. یعنی ما یک کلاس می‌سازیم (مثل ParserFacade) که مسئول هماهنگ کردن و مدیریت کردن کارهای مربوط به سیستم‌های داخلی (مثل Parser) هست. در این صورت بقیه کدها، مثل Main، دیگر لازم نیست درگیر جزئیات پیچیده بشوند و فقط از این رابط ساده استفاده می‌کنند. این کار هم کد را خواناتر می‌کند و هم وابستگی بین بخش‌های مختلف کد را کم می‌کند.


 **اعمال الگوی Separate Query From Modifier:**

در این قسمت Separate Query from Modifier را پیاده سازی کردیم. این الگوی طراحی می‌گوید که بهتر است متدها یا فقط اطلاعات را برگردانند (Query) یا وضعیت برنامه را تغییر بدهند (Modifier)، نه اینکه هر دو کار را با هم انجام بدهند. این کار باعث می‌شود کد خیلی تمیزتر، واضح‌تر و قابل پیش‌بینی‌تر شود.  حال در این کدی که تغییر دادیم، یک‌سری متد مثل getTemp() و getDateAddress() هم مقدار را برمی‌گردانند و هم وضعیت برنامه را تغییر می‌دادند (مثلا مقدار یک متغیر را زیاد می‌کردند). این کار باعث می‌شد هر بار که این متدها کال می‌شدند، وضعیت برنامه یک جورایی مخفیانه تغییر می‌کرد و ممکن بود باگ‌ها و مشکلات عجیبی پیش بیاد.  برای حل این مشکل، متدهایی مثل increaseTemp() و increaseDateAddress() را جدا کردیم که فقط وظیفه تغییر وضعیت را دارند. در عوض getTemp() و getDateAddress() فقط مقدار را برمی‌گردانند بدون اینکه تغییری ایجاد کنند. 

در این صورت خیلی راحت می‌شود فهمید که هر متد دقیقا چه کاری انجام می‌دهد و رفتار برنامه هم قابل پیش‌بینی‌تر می‌شود. همچنین تست کردن کد خیلی آسان‌تر می‌شود، چون می‌توان متدهای تغییر وضعیت و متدهای برگرداندن اطلاعات را جداگانه تست کرد؛ یا خطاهای عجیبی که به خاطر تغییرات غیرمنتظره پیش می‌آید خیلی کمتر شود و برنامه پایدارتر شود.  مثلا در کلاس CodeGenerator اول increaseTemp() را کال می‌کنیم تا وضعیت آپدیت شود و بعدش getTemp() مقدار نهایی را برمی‌گرداند. یا در SymbolTable هم همین کار را کردیم و قبل از استفاده از مقدار جدید، متد increaseDateAddress() وضعیت را آپدیت می‌کند.
