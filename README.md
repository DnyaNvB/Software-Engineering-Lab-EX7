kanban board link: https://github.com/users/DnyaNvB/projects/6


در ابتدا پروژه را از گیت‌هاب درس برداشته و طبق گفته‌ی صورت آزمایش، تنها MiniJava را نگه‌میداریم و Graph را از پروژه حذف می‌کنیم.
در ادامه الگوهای طراحی ذکر شده در صورت سوال را اعمال می‌کنیم:

 **اعمال الگوی Facade:**

۱- یک مشکل اساسی که وجود داشت این بود که کلاس LexicalAnalyzer مستقیما در Parser استفاده می‌شد و این باعث می‌شد وابستگی خیلی زیاد شود، خوانایی کم شود و کد خیلی پیچیده به نظر بیاید. برای حل این مشکل از الگوی طراحی Facade استفاده کردیم و یک کلاس جدید به اسم ScannerFacade ساختیم. این کلاس نقش یه واسط ساده را داشت که پیچیدگی‌های LexicalAnalyzer را از Parser پنهان کرد و کار را خیلی راحت‌تر کرد. برای اعمال این الگو در ابتدا ScannerFacade را ساختیم تا مدیریت ارتباط با LexicalAnalyzer را انجام دهد، سپس Parser را اصلاح کردیم که دیگر مستقیم با LexicalAnalyzer کار نکند و از ScannerFacade استفاده کند. در نهایت بعد از تغییرات خروجی‌مان را با خروجی کد اصلی تست کردیم تا مطمئن شویم همه چیز درست کار می‌کند. با این کار، پیچیدگی تحلیل واژگانی پنهان شد، وابستگی بین Parser و LexicalAnalyzer کمتر شد، کد خواناتر و راحت‌تر برای نگهداری شد و تست و توسعه پروژه هم ساده‌تر شد همچنین انعطاف‌پذیرتر شد.

۲- در این قسمت، قبلا در کلاس Main همه جزئیات مربوط به پارسینگ مستقیم نوشته می‌شد. یعنی Main هم باید شی Parser را می‌ساخت و هم خودش عملیات شروع پارسینگ را انجام می‌داد. این کار باعث می‌شد کد هم شلوغ بشه و هم خیلی وابسته به جزئیات پیاده‌سازی کلاس Parser باشد. حال در این تغییر آمدیم یه کلاس جدید به اسم ParserFacade ساختیم. این کلاس عملا یه واسط یا همان Facade شده بین کلاس Main و کلاس Parser. یعنی Main دیگر لازم نیست درگیر جزئیات کار Parser شود و فقط کافی است یه شی از ParserFacade بسازد و متد parseInput را کال کند. در واقع ParserFacade خودش داخلش کارهای مربوط به Parser را انجام می‌دهد و اگه خطایی هم پیش بیاید، همان‌جا هندل می‌کند. در این صورت همه مسئولیت‌های پارسینگ و مدیریت خطاها از Main جدا شده و به یک کلاس مستقل منتقل شده. 

همچنین برای خطاها هم یک تغییر کوچیکی در کلاس Main دادیم که اگر فایل پیدا نشد، پیام واضح‌تری چاپ می‌شود: "file not found". اما اگر خطای دیگه‌ای داخل پارسینگ رخ بدهد، این خطا در ParserFacade مدیریت می‌شود و پیام مناسب "An error occurred during parsing" چاپ می‌شود.

نقش Facade Pattern دقیقا همین است که در کدهای پیچیده یک رابط ساده و قابل استفاده به بیرون ارائه دهد. یعنی ما یک کلاس می‌سازیم (مثل ParserFacade) که مسئول هماهنگ کردن و مدیریت کردن کارهای مربوط به سیستم‌های داخلی (مثل Parser) هست. در این صورت بقیه کدها، مثل Main، دیگر لازم نیست درگیر جزئیات پیچیده بشوند و فقط از این رابط ساده استفاده می‌کنند. این کار هم کد را خواناتر می‌کند و هم وابستگی بین بخش‌های مختلف کد را کم می‌کند.

 **اعمال الگوی استفاده از Polymorphism به جای شرط:**

این الگوی بازآرایی در کدهایی مناسب است که ما یک شرطی داریم که بسته به خصوصیات مختلف اعمال مختلفی را انجام می دهد، برای مثال switch case ها. برای بازآرایی این نوع کد ها با کمک polymorphism می‌بایست کلاس های فرعی مطابق با شاخه های شرطی ایجاد کنیم، سپس در آنها یک متد اشتراکی ایجاد می‌کنیم و کد را از شاخه مربوط به شرطی به آن منتقل می‌کنیم. سپس شرط را با فراخوانی متد مربوطه جایگزین کرده و  نتیجه این است که پیاده سازی مناسب از طریق پلی مورفیسم بسته به کلاس شی حاصل می شود. 

در این پروژه ما این بازآرایی رو کلاس address و به ویژه تابع to string انجام می‌دهیم که از شرط به صورت switch case استفاده کرده است. برای اینکار باید TypeAddress enum را با polymorphism جایگذاری کنیم. در ابتدا یک اینترفیس AddressType می‌سازیم و در آن تابع format را تعریف می‌کنیم برای هر کدام از تایپ‌‌های آدرس که در switch case ها داشتیم. به این ترتیب، با فراخوانی این تابع، به‌طور خودکار عملکرد switch-case حذف شده انجام می‌شود. سپس برای هر کدام از آدرس تایپ‌ها یک کلاس جداگانه تعریف می‌کنیم.اگر شیئی که تابع بر روی آن فراخوانی می‌شود از هر یک از انواع این کلاس‌ها باشد، تابع مربوط به آن کلاس به‌طور صحیح اجرا خواهد شد. در نتیجه این تغییرات modification های مورد نیاز را بر روی فایل codeGenerator نیز اعمال میکنیم. 


 **اعمال الگوی Separate Query From Modifier:**

در این قسمت Separate Query from Modifier را پیاده سازی کردیم. این الگوی طراحی می‌گوید که بهتر است متدها یا فقط اطلاعات را برگردانند (Query) یا وضعیت برنامه را تغییر بدهند (Modifier)، نه اینکه هر دو کار را با هم انجام بدهند. این کار باعث می‌شود کد خیلی تمیزتر، واضح‌تر و قابل پیش‌بینی‌تر شود.  حال در این کدی که تغییر دادیم، یک‌سری متد مثل getTemp() و getDateAddress() هم مقدار را برمی‌گردانند و هم وضعیت برنامه را تغییر می‌دادند (مثلا مقدار یک متغیر را زیاد می‌کردند). این کار باعث می‌شد هر بار که این متدها کال می‌شدند، وضعیت برنامه یک جورایی مخفیانه تغییر می‌کرد و ممکن بود باگ‌ها و مشکلات عجیبی پیش بیاد.  برای حل این مشکل، متدهایی مثل increaseTemp() و increaseDateAddress() را جدا کردیم که فقط وظیفه تغییر وضعیت را دارند. در عوض getTemp() و getDateAddress() فقط مقدار را برمی‌گردانند بدون اینکه تغییری ایجاد کنند. 

در این صورت خیلی راحت می‌شود فهمید که هر متد دقیقا چه کاری انجام می‌دهد و رفتار برنامه هم قابل پیش‌بینی‌تر می‌شود. همچنین تست کردن کد خیلی آسان‌تر می‌شود، چون می‌توان متدهای تغییر وضعیت و متدهای برگرداندن اطلاعات را جداگانه تست کرد؛ یا خطاهای عجیبی که به خاطر تغییرات غیرمنتظره پیش می‌آید خیلی کمتر شود و برنامه پایدارتر شود.  مثلا در کلاس CodeGenerator اول increaseTemp() را کال می‌کنیم تا وضعیت آپدیت شود و بعدش getTemp() مقدار نهایی را برمی‌گرداند. یا در SymbolTable هم همین کار را کردیم و قبل از استفاده از مقدار جدید، متد increaseDateAddress() وضعیت را آپدیت می‌کند.


 **اعمال الگوی Self Encapsulated Field:**

این الگو به این معناست که وقتی شما به طور مستقیم به فیلدهای خصوصی یک کلاس دسترسی دارید، باید این دسترسی را با ایجاد getter و setter برای آن فیلدها جایگزین کنید. به این ترتیب، فقط از این متدها برای دسترسی به فیلد استفاده می‌کنید و این کار باعث می‌شود که کنترل بیشتری بر روی نحوه‌ی دسترسی و تغییرات فیلدها داشته باشید.

برای پیاده سازی این الگو از کلاس Address استفاده میکنیم که مشاهده می‌شود در آن متغیر ها به صورت پابلیک تعریف شده اند و برای بازآرایی این کد کافیست ما توابع getter و setter را همانطور که در کامیت مربوطه مشاهده می‌شود در جاهایی که لازم می‌باشد پیاده سازی کنیم و متغیرها را پرایوت کنیم. سپس کد مربوط به CodeGenerator را با توجه به رفکتورینگ انجام شده در جاهای مورد نیاز modify میکنیم تا اجرای پروژه به مشکل نخورد.

**اعمال الگوی دلخواه Extract Method:**


این متد ریفکتورینگ  برای شکستن متدهای طولانی یا پیچیده به متدهای کوچک‌تر و مستقل استفاده می‌شود. هدف اصلی آن بهبود خوانایی، افزایش قابلیت استفاده مجدد، و کاهش پیچیدگی کد است. متدهای طولانی‌تر مانند pintCodeBlock و add3AddressCode به متدهای کوچک‌تر تقسیم شدند تا خوانایی و نگهداشت کد بهبود یابد. برای مثال، متدی به نام add3AddressCodeInternal استخراج شد که منطق افزودن یک شیء _3AddressCode به لیست را مدیریت می‌کند. همچنین، برای چاپ ورودی‌های کد، متدهایی مانند printCodeBlockEntry و formatCodeBlockEntry ایجاد شدند تا مسئولیت‌ها بهتر تفکیک شوند. در کلاس _3AddressCode نیز فرمت‌دهی رشته‌ها به کمک متدهای کمکی مانند operationToString و operandToString ساده‌تر و قابل‌مدیریت‌تر شد.

متد pintCodeBlock به چند متد کوچک‌تر تقسیم شد: printCodeBlockEntries برای مدیریت حلقه چاپ، printCodeBlockEntry برای چاپ هر ورودی به صورت جداگانه، و formatCodeBlockEntry برای فرمت‌دهی به هر ورودی. این تغییرات باعث شد که کد خواناتر شود، مسئولیت‌ها بهتر تقسیم شوند، و تغییرات آینده ساده‌تر شوند.

**اعمال الگوب دلخواه Parametrize method:**

در این ریفکتورینگ، از روش Parameterize Method استفاده شد تا متدهای تکراری add، sub و mult که منطق مشابهی داشتند، به یک متد عمومی‌تر به نام arithmeticOperation تبدیل شوند. این متد جدید با دریافت نوع عملیات (Operation) و پیام خطا به‌عنوان پارامتر، منطق مشترک را اجرا می‌کند. سپس متدهای اصلی به فراخوانی این متد با مقادیر مناسب تغییر یافتند. این کار باعث کاهش تکرار کد، بهبود خوانایی و افزایش قابلیت نگهداری شد.


**افزودن افزونه Formatter به pom.xml**
برای فرمت‌بندی کدهای پروژه، افزونه formatter-maven-plugin را به بخش <plugins> در فایل pom.xml پروژه اضافه کردیم.

در ابتدا، نام گروه (groupId)، شناسه (artifactId) و نسخه (version) افزونه را مشخص کرده‌ایم:

```
<plugin>
    <groupId>net.revelc.code.formatter</groupId>
    <artifactId>formatter-maven-plugin</artifactId>
    <version>2.15.0</version>
    <configuration>
        <encoding>UTF-8</encoding>
        <directories>
            <directory>${project.build.sourceDirectory}</directory>
            <directory>${project.build.directory}/generated-sources</directory>
        </directories>
    </configuration>
</plugin>

```


برای اعمال فرمت‌بندی کدها، از دستور زیر استفاده کردیم:



```
mvn formatter:format

```


![image](https://github.com/user-attachments/assets/f60d46dc-1d2f-4ad8-af6b-c904d8bdf776)


![image](https://github.com/user-attachments/assets/08c9fb15-3d1a-43af-97da-58537bcc6da4)






**سوالات:**


**سوال ۱:**


کد تمیز (Clean Code):
کدی که ساده، قابل خواندن، قابل درک برای دیگر توسعه‌دهندگان و به راحتی قابل نگهداری و توسعه باشد و کمترین پیچیدگی و ابهام را داشته باشد. به عبارتی کد تمیز کدی است که بعد از دو هفته آن کدی که خودمان نوشتیم را ببینیم (یا دگیران ببینند) بتوانیم ازش سر دربیاوریم و بدون مشکل آن را تغییر دهیم (در صورت لزوم).

بدهی فنی (Technical Debt):
هزینه‌ی اضافی و کارهای عقب‌افتاده‌ای است که به‌دلیل راه‌حل‌های میان‌بر و غیر اصولی در کد، در آینده برای نگهداری و توسعه گریبان‌گیر ما می‌شود. (در ابتدا قصد دارند کیفیت را فدای سرعت و راه حل‌های موقت کنند و ولی در انتها ضرر می‌کنند و احتمالا باید زمان بیشتری بگذارند تا اصلاحش کنند.).

بوی بد کد (Bad Smell):
نشانه‌ای در کد که نشان‌دهنده وجود اشکال در طراحی، ساختار یا پیاده‌سازی است و می‌تواند در آینده مشکلات نگهداری و توسعه ایجاد کند. مثلا کدی که فعلا کار می‌کند ولی حس می کنیم که یک چیزی این قسمت اشتباه است

**سوال ۲:**

**۱- بادکنکی‌ها یا Bloaters**

بخش‌هایی از کد، کلاس‌ها یا متدهایی که بیش از حد بزرگ یا پیچیده شده‌اند و فهمیدن آن برایمان یا مدیریت و کار با آن‌ها برایمان دشوار شده است.
این مشکلات معمولا به مرور زمان به‌خصوص وقتی که کسی تلاشی برای بهبود آنها نکند، ایجاد می‌شوند.

برای مثال:

متد طولانی (long method): متدی که وظایف زیادی انجام می‌دهد و بیش از حد طولانی شده است.

کلاس بزرگ (large class): کلاسی که مسئولیت‌های زیادی دارد و باید به چند کلاس کوچک‌‌تر تقسیم شود.

شیفتگی به انواع اولیه (primitive obsession): استفاده بیش از حد و متعصبانه از primitive‌ها به جای کلاس‌های پیچیده‌تر.

لیست پارامتر طولانی (long parameter list): متدی که تعداد زیادی پارامتر می‌گیرد و باعث پیچیدگی می‌شود.
      
توده داده‌ها (data clumps): دسته‌ای از داده‌ها که همیشه با هم ظاهر می‌شوند و باید به یک کلاس مستقل تبدیل شوند.


**۲- سوءاستفاده‌کنندگان شی‌گرایی (Object-Orientation Abusers**)

این دسته شامل مواردی است که اصول برنامه‌نویسی شی‌گرا به درستی یا کامل اجرا نشده‌اند  مثلا استفاده نابه‌جا از switch یا درست رعایت نکردن وراثت که به طور جزئی‌تر مثال‌هایی در ادامه زدیم.

مثال:

کلاس‌های جایگزین با رابط‌های متفاوت (Alternative Classes with Different Interfaces): کلاس‌هایی که مسئولیت‌های مشابهی دارند اما به شکل متفاوتی پیاده‌سازی شده‌اند.

ارث‌بری رد شده (Refused Bequest): زمانی که یک کلاس فرزند از قابلیت‌های کلاس والد استفاده نمی‌کند.

دستورهای switch (Switch Statements): استفاده از دستورهای شرطی زیاد به جای استفاده از پلی‌مورفیسم.

فیلد موقت (Temporary Field): فیلدی که فقط در شرایط خاصی مقداردهی می‌شود و استفاده مداومی ندارد.


**۳- تغییرناپذیرها یا موانع تغییر (Change Preventers)**

کدهایی که با تغییر در یک بخش، نیاز به تغییرات زنجیره‌ای و گسترده در بخش‌های دیگر ایجاد می‌کند و توسعه‌ی کد را هزینه‌بر و سخت می‌کند.

برای مثال:

تغییر واگرا (Divergent Change): یک کلاس که نیازمند تغییرات متفاوت برای نیازهای مختلف است.

سلسله‌مراتب‌های ارث‌بری موازی (Parallel Inheritance Hierarchies): زمانی که برای اضافه کردن یک قابلیت، باید در چندین کلاس مرتبط تغییرات اعمال شود.

جراحی پراکنده (Shotgun Surgery): تغییر در یک بخش نیازمند تغییرات پراکنده در بخش‌های دیگر است.


**۴- غیرضروری‌ها یا زائد‌ها (Dispensables)**
   
مواردی هستند که بودنشان هیچ ارزشی به کد اضافه نمی‌کند (غیر ضروری و یا بلااستفاد) و حتی باعث پیچیدگی بیشتر می‌شود. حذف این بخش‌ها کد را تمیزتر، ساده‌تر بهینه‌تر و قابل فهم‌تر می‌کند.

  برای مثال:

کامنت‌های اضافی: توضیحاتی که به جای روشن کردن کد، پیچیدگی یا ابهام ایجاد می‌کنند.
        
کد تکراری (duplicate): کدهایی که در بخش‌های مختلف کپی شده‌اند به جای اینکه در یک مکان مشترک استفاده شوند.

کد مرده (dead code): بخش‌هایی از کد که دیگر استفاده نمی‌شوند.
        
کلاس تنبل (lazy class): کلاسی که کار خاصی انجام نمی‌دهد و می‌تواند حذف یا با کلاس دیگری ترکیب شود.

**۵- اتصال‌دهنده‌ها (Couplers)**

این بوها نشان‌دهنده وابستگی بیش از حد بین کلاس‌ها یا استفاده افراطی از واگذاری مسئولیت هستند که باعث پیچیدگی و سختی مدیریت می‌شود.

برای مثال:

حسادت به ویژگی‌ها (Feature Envy): زمانی که یک کلاس بیش از حد به داده‌های کلاس دیگر وابسته است و از عناصر آن استفاده می‌کند.

صمیمیت نامناسب (Inappropriate Intimacy): دو کلاس که بیش از حد به جزئیات داخلی یکدیگر وابسته هستند.
        
کلاس کتابخانه ناقص (Incomplete Library Class): کلاسی که باید قابلیت‌های بیشتری ارائه دهد اما ناقص است.
        
زنجیره پیام‌ها (Message Chains): زمانی که یک آبجکت به طور مکرر از چند شی دیگر درخواست می‌کند.
        
واسطه‌گری غیرضروری (Middle Man): کلاسی که فقط درخواست‌ها را به کلاس دیگر منتقل می‌کند و خودش کار خاصی انجام نمی‌دهد.


**سوال ۴:**

پس از بررسی فایل های مربوط به پروژه تبدیل مدل به سی به نمونه‌هایی از بوی بد در کدها رسیدیم که در ادامه به ۱۰ مورد از آن‌ها اشاره شده است:

۱- Large Class and Long Method:


در مد مربوز به کلاس main مشاهده می‌شود که تعداد زیادی متد طولانی مانند خود تابع Main وجود دارد که باعث بزرگ شدهن کلاس Main شده است، بهتر است این متدها کوتاه تر و متمرکز تر باشند و یا در صورت امکان به کلاس دیگری منتقل بشموند. این کلاس به طور هم‌زمان چندین مسئولیت را بر عهده دارد که این موضوع با اصل مسئولیت واحد در تناقض می‌باشد.

۲- Feature Envy:

. در کلاس Main، مشاهده می‌شود که  متد loopOnGUI نمونه‌ای از Feature Envy است. این بوی بد زمانی رخ می دهد که در یک کلاس متدی وجود داشته باشد که بیشتر به داده‌‌های دیگری علاقه‌مند باشد تا داده‌ّای موجود در کلاس خود. این موضوع در متد loopOnGUI مشاهده می‌شود، به گونه‌ای که این متد به داده‌های کلاس GUIDiagram بیشتر علاقه مند و وابسته است.

۳- Lazy Class:

در کد داده شده مشاهده می‌شود که کلاس CommandExecutor  برای مثال متدهای خیلی کمی دارد که می ةواند با کلاس‌های دیگر ادغام شود یا متدهای مورد ساتفاده بیشتری را در بر بگیرد تا هزینه مربوط به آن متعادل تر شود.

۴- Switch Statements (Conditional Complexity):

در کلاس Main مشاهده می‌شود که متد Main منطق شرطی با عبارات if متعدد و دستور switch باعث می شود که دنبال کردن جریان سخت شود. مفید است که این منطق را به روش‌های جداگانه تغییر دهیم یا از یک command pattern برای مدیریت آرگومان‌های مختلف استفاده کنیم.

۵- Tight Coupling:

این بوی بد در طراحی نرم‌افزار به وضعیتی اشاره دارد که در آن یک کلاس یا ماژول به شدت به پیاده‌سازی‌های خاص دیگر کلاس‌ها وابسته است، که این امر باعث می‌شود کد سخت‌تر قابل نگهداری، آزمایش و تغییر باشد. در این پروژه در کلاس Main مشاهده می شود که عملیات GUI و مدیریت XML به یکدیگر پیوند خورده اند و این موضوع باعث میشود تغییر یا دیباگ آن ها مشکل باشد. برای مثال تغییر در یک بخش (مثلاً تغییر در نحوه مدیریت XML) ممکن است تأثیرات غیرمنتظره‌ای بر بخش دیگر (مثلاً رابط کاربری) بگذارد. این وابستگی‌ها می‌توانند منجر به بروز خطاهای جدید شوند.

۶-  Inappropriate Intimacy:

این بوی بد به وضعیتی اشاره دارد که در آن یک کلاس یا ماژول به طور غیرضروری به جزئیات پیاده‌سازی کلاس یا ماژول دیگری وابسته است. این نوع وابستگی می‌تواند منجر به مشکلاتی در نگهداری و توسعه نرم‌افزار شود. در این پروژه در کلاس Main مشاهده می‌شود که وابستگی زیاد و غیر ضروری‌‌‌ای به GUIDiagram وجود دارد. می‌توان از الگوهای طراحی مانند Dependency Injection، Observer Pattern و Interface Segregation Principle استفاده کرد. این الگوها کمک می‌کنند تا وابستگی‌ها را کاهش داده و کد انعطاف‌پذیرتر و قابل نگهداری‌تر شود.


۷- Dead Code:

کد مرده به بخش‌هایی از کد اشاره دارد که هرگز اجرا نمی‌شوند یا به هیچ دلیلی مورد استفاده قرار نمی‌گیرند. در کلاس Main در تابع generateInfoForXML بخشی از کد کامنت شده است. این بخش از کد به عنوان "کد مرده" شناخته می‌شود، زیرا هیچ‌گاه اجرا نمی‌شود و در حال حاضر غیر فعال است. با حذف کردن این بخش کد ما می‌ةواند خوانایی بیشتری داشته باشد.

۸- Magic Numbers:

در کلاس Main و در تابع loopOnGUI() این بوی بد مشاهده می‌شود. در کد، مقادیر 15 و 4 به عنوان شرایطی برای شمارش استفاده شده‌اند. این مقادیر به وضوح معنای خاصی ندارند و بهتر است به صورت ثابت (constant) تعریف شوند تا خوانایی بهتری داشته باشند. همچنین اعدادی مانند 1999 در متد run و ابعادی مانند 1500 و 750 در متد initializeGUI به‌صورت هارد‌کد شده‌اند که این موضوع نیز خوانایی و انعطاف‌پذیری کد را کاهش می‌دهد

۹- Duplicated Code:

در کلاس Main، منطق مدیریت وضعیت BasicDiagramStatus و GraphOperation در دو متد generateInfoForXML و loopOnGUI تکرار شده است. این موضوع باعث ایجاد افزونگی می‌شود و نگهداری کد را دشوارتر می‌کند. برای حل این مشکل می‌بایست منطق تکراری را به یک متد جداگانه منتقل کرد و از آن در هر دو متد استفاده شود تا قابلیت نگهداری کد بهبود یابد.


۱۰- Global State:

بسیاری از فیلدهای استاتیک (مانند documentFactory، documentBuilder، document، transformer، guiDiagram و غیره) وابستگی‌های ضمنی بین متدها ایجاد می‌کنند و تست‌پذیری کد را کاهش می‌دهند.
برای حل این موضوع می‌توانیم فیلدهای استاتیک را با فیلدهای نمونه (instance fields) جایگزین کنیم یا وابستگی‌ها را به‌طور صریح از طریق پارامترهای متد یا constructors منتقل کنیم.

۱۱- Threading Issues:

در کلاس Main متد  run یک حلقه پیوسته با خواب (sleep) ایجاد می‌کند که ممکن است بهترین روش برای به‌روزرسانی‌های GUI نباشد. این موضوع می‌تواند منجر به مشکلات عملکرد یا رفتار غیرقابل پاسخ شود.
می‌توان از یک مکانیزم زمان‌بندی مناسب یا ابزارهای Swing مانند javax.swing.Timer برای به‌روزرسانی‌های دوره‌ای استفاده کرد.
